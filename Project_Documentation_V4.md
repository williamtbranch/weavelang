# Project Documentation: WeaveLang - Spanish CI Learning Application - Version 4

**Document Version: 4.0**
**Last Updated:** (Date of this session)

**Note for LLM (Context for Future Sessions):**
This document, `Project_Documentation_V4.md`, is the primary specification for the "WeaveLang" project. It details a multi-call LLM pipeline for data pre-processing.

## 1. Project Overview & Goal

*   **Name:** WeaveLang - Spanish CI Learning Application
*   **Goal:** To facilitate Spanish language acquisition for learners, using a Comprehensible Input (CI) methodology. This project focuses on creating robust pre-processed learning content from literary works.
*   **Methodology:** The application (envisioned) will provide learners with extensive listening input. Input is carefully scaffolded using a static generation model, with content pre-generated by a sophisticated LLM pipeline and then processed by a Rust application.
*   **Content Source:** Public domain literary texts.
*   **Target Audience:** English speakers learning Spanish.
*   **Primary Medium:** Audio-based learning (TTS generated from text produced by the Rust application).
*   **Development Context:** Solo developer, leveraging LLM heavily for pre-processing. Python for LLM interaction scripts (`stage2llm.py`, `llm_prompts.py`), Zig/Rust for core generation application.

## 2. Core Learning Methodology & Generation Levels (Rust Application)

The Rust application will use the pre-processed data to generate output text for the learner based on a hypothetical learner profile. The generation strategy involves these levels, attempted in order:

*   **L0: Full Advanced Spanish (`AdvS`)**
    *   Uses the complete `AdvS` text.
    *   Condition: All lemmas in the overall `AdvSL` (lemmas for the full `AdvS` text) are Known/Active (K/A) in the learner's profile.

*   **L1: Woven Advanced Spanish (`AdvS_Segments`) / Simpler Advanced Spanish (`SimplerAdvS_Segments`)** (Bridging Level)
    *   Takes `AdvS_Segments` (segments of the `AdvS` text) and their corresponding `SimplerAdvS_Segments` (same structure, simpler vocabulary).
    *   For each `AdvS_Segment`:
        *   If its advanced lemmas (`AdvSL_per_AdvS_Segment`) are K/A, use the `AdvS_Segment` text.
        *   Else, if the lemmas for its corresponding `SimplerAdvS_Segment` (`L1_SimplerAdvSL`) are K/A, use the `SimplerAdvS_Segment` text.
        *   Else (Fallback): Use the corresponding `Eng_Span_for_AdvS_Segment` (requires `PHRASE_ALIGN_AdvS_to_Eng` data, see Section 4).
    *   Output: Concatenation of chosen segments. Chosen if it produces at least some Spanish (Advanced or Simpler Advanced).

*   **L2: Full Simple Spanish (`SimS_L2`)**
    *   Uses the `SimS_L2_Text` (a direct, holistic simple Spanish translation of `Eng`).
    *   Condition: All lemmas in `L2_SimSL` (lemmas for `SimS_L2_Text`) are K/A.

*   **L3: Woven Simple Spanish (`SimS_L3_Segments`) / English (`Eng_Spans`)**
    *   Uses `SimS_L3_Segments` (simple Spanish segments structurally aligned to `Eng`) and `Eng_Spans` (from the original `Eng` text, via `PHRASE_ALIGN_SimS_L3_to_Eng`).
    *   For each `SimS_L3_Segment`:
        *   If its lemmas (`L3_SimSL`) are K/A, use the `SimS_L3_Segment` text.
        *   Else, use its aligned `Eng_Span`.
    *   Output: Concatenation of chosen segments. Chosen if it produces at least some `SimS_L3_Segment` text.

*   **L4: Diglot English (`Eng`) / Spanish Word Substitutions**
    *   Uses the original `Eng` text as a base.
    *   Substitutes individual English words with their Spanish `ExactSpaForm` from the `DIGLOT_MAP` if the `SpaLemma` is K/A and the `ViabilityFlag` is (Y). Aims for one substitution per original `SimS_L3_Segment` conceptual boundary.

*   **L5: Full English (`Eng`)**
    *   Uses the original `Eng` (source) text. Ultimate fallback.

(Vocabulary Tracking, Pacing, CT, Saturation logic details remain similar to V3 but apply to these new level definitions and data.)

## 3. Core System Components

*   **Learner Profile Database (Hypothetical):** (As in V3)
*   **Content Data Structure Database (JSON):** Stores the pre-processed JSON data for each sentence, output by the Zig/Rust Helper Tool from the `.llm.txt` files.
*   **Pre-computation Module:** (As in V3)
*   **Static Generation Engine (Zig/Rust):** Core algorithm processing JSON data and hypothetical Learner Profile state to generate final concatenated batch text according to the L0-L5 Adaptive Strategy.
*   **TTS Generation Module (Python Script):** (As in V3)
*   **Helper Tool (Parser/Validator/JSON Encoder - Zig/Rust):** Converts final `.llm.txt` format to JSON database structure. Performs structural validation.
*   **LLM Data Generation Scripts (Python - `stage2llm.py`, `llm_prompts.py`):**
    *   `stage2llm.py`: Orchestrates a 6-call sequential pipeline to the LLM for each batch of sentences. Manages data flow between calls, parsing LLM responses, and final assembly of `.llm.txt` blocks.
    *   `llm_prompts.py`: Loads prompt templates from `.txt` files and formats them with batch-specific data for each of the 6 LLM calls.
*   **LLM (External API, e.g., Claude, Gemini):** Used offline by `stage2llm.py` for the 6-step data generation process.
*   **Bundler/Unbundler Scripts:** (As in V3)

## 4. Data Pre-processing (LLM Multi-Call Pipeline & Final `.llm.txt` Format)

The LLM data generation is now a **6-call pipeline** orchestrated by `stage2llm.py` for each batch of original English sentences (`Eng`). Each call has a focused task. The results from these calls are assembled into a final structured block for each sentence in an `.llm.txt` file.

**Input to Pipeline:** Original English sentences from staged text files (e.g., `AW.txt`).

**LLM Call Pipeline Overview:**

1.  **Call 1: `Eng` -> `AdvS_Text` & `AdvSL_Overall`**
    *   Input: `Eng` text.
    *   Output: `AdvS_Text` (advanced Spanish translation), `AdvSL_Overall` (flat lemma list for `AdvS_Text`).
2.  **Call 2: `Eng` -> `SimS_L2_Text` & `L2_SimSL`**
    *   Input: `Eng` text.
    *   Output: `SimS_L2_Text` (direct simple Spanish translation for L2), `L2_SimSL` (lemmas for `SimS_L2_Text`).
3.  **Call 3: `AdvS_Text` -> `AdvS_Segments` & `AdvSL_per_AdvS_Segment`**
    *   Input: `AdvS_Text` (from Call 1), original `Eng` (for context).
    *   Output: `AdvS_Segments` (segmented `AdvS_Text`), `AdvSL_per_AdvS_Segment` (lemmas for each `AdvS_Segment`). Segment IDs are A-type (A1, A2...).
4.  **Call 4: `AdvS_Segments` -> `SimplerAdvS_Segments` & `L1_SimplerAdvSL`**
    *   Input: `AdvS_Segments` (texts & IDs from Call 3), original `Eng`/`AdvS` (for context).
    *   Output: `SimplerAdvS_Segments` (simpler vocab, structurally matching input `AdvS_Segments`), `L1_SimplerAdvSL` (lemmas for each `SimplerAdvS_Segment`). Segment IDs are A-type, matching input.
5.  **Call 5: `Eng` -> `SimS_L3_Segments`, `PHRASE_ALIGN_SimS_L3_to_Eng`, & `L3_SimSL`**
    *   Input: `Eng` text.
    *   Output:
        *   `SimS_L3_Segments` (simple Spanish segments structurally aligned to `Eng`). Segment IDs are S-type (S1, S2...).
        *   `PHRASE_ALIGN_SimS_L3_to_Eng` (aligns `SimS_L3_Segment_Text` to `Eng_Span_Text`).
        *   `L3_SimSL` (lemmas for each `SimS_L3_Segment`).
6.  **Call 6: `Eng`, `SimS_L3_Segments`, Alignments, `L3_SimSL` -> `DIGLOT_MAP`**
    *   Input: `Eng` text, and outputs from Call 5.
    *   Output: `DIGLOT_MAP` (maps `EngWords` from `Eng_Spans` to `SpaLemma(ExactSpaForm)(ViabilityFlag)`), structured per S-type segment ID.

**Final Assembled `.llm.txt` Block Structure (per sentence):**
```text
AdvS:: {{[AdvS_Text from Call 1]}}
SimS:: {{[SimS_L2_Text from Call 2]}}
Eng:: {{[Original Eng_Text]}}

SimS_Segments::
S1::{{[SimS_L3_Segment_Text_S1 from Call 5]}}
S2::{{[SimS_L3_Segment_Text_S2 from Call 5]}}
// ...

PHRASE_ALIGN::
S1 ~ {{[SimS_L3_Segment_Text_S1 from Call 5]}} ~ {{[Eng_Span_Text_S1 from Call 5]}}
S2 ~ {{[SimS_L3_Segment_Text_S2 from Call 5]}} ~ {{[Eng_Span_Text_S2 from Call 5]}}
// ...

SimSL::
S1::[L3_SimSL_lemmas_for_S1 from Call 5]
S2::[L3_SimSL_lemmas_for_S2 from Call 5]
// ...

AdvSL:: [AdvSL_Overall_lemmas_string from Call 1]

DIGLOT_MAP::
S1::[Diglot_entries_for_S1 (EngWord->SpaLemma(ExactSpaForm)(V)) from Call 6]
S2::[Diglot_entries_for_S2 from Call 6]
// ...

AdvS_Segments_Data:: // NEW SECTION
A1_TEXT::{{[AdvS_Segment_Text_A1 from Call 3]}}
A1_LEMMAS::[AdvSL_for_AdvS_Segment_A1 from Call 3]
A1_SIMPLER_TEXT::{{[SimplerAdvS_Segment_Text_A1 from Call 4]}}
A1_SIMPLER_LEMMAS::[L1_SimplerAdvSL_for_SimplerAdvS_Segment_A1 from Call 4]
A2_TEXT::{{[AdvS_Segment_Text_A2 from Call 3]}}
// ... and so on for all A-type segments
A2_SIMPLER_LEMMAS::[L1_SimplerAdvSL_for_SimplerAdvS_Segment_A2 from Call 4] 

END_SENTENCE